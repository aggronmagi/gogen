package option

import (
	"os"
	"strings"

	"github.com/aggronmagi/gogen/gen"
	"github.com/aggronmagi/gogen/goparse"
	"github.com/aggronmagi/gogen/internal/util"
)

func generate(pkg *goparse.Package, st *optionStruct) {
	g := &gen.Generator{
		FormatSource: gen.OptionGoimportsFormtat,
	}

	// Print the header and package clause.
	g.Printf("// Code generated by \"gogen option\"; DO NOT EDIT.\n")
	g.Printf("// Exec: \"gogen %s\"\n// Version: %s \n",
		strings.Join(os.Args[1:], " "), Version)
	g.Printf("\n")
	g.Printf("package %s", pkg.Package().Name)
	g.Printf("\n")
	g.Println("import (")
	for _, v := range pkg.Package().Imports {
		g.Printf("%s \"%s\"\n", v.Name, v.PkgPath)
	}
	g.Println(")")
	g.Println()

	g.Println("var _ = ", st.FromFunc, "()")

	g.PrintDoc(st.Document)
	g.Println("type ", st.Name, " struct {")
	for _, v := range st.Fields {
		g.PrintDoc(v.Document)
		g.Print(v.Name, " ", v.Type)
		if len(v.Comment) > 0 {
			g.PrintDoc(v.Comment[0])
		} else {
			g.Println()
		}
	}
	g.Println("}")

	// Modify option functions
	for _, v := range st.Fields {
		g.PrintDoc(v.Document)
		g.Print("func ", v.GenFuncName(st), "(v ")
		if v.IsSlice() {
			g.Print("...", v.SliceType())
		} else {
			g.Print(v.Type)
		}
		g.Println(")", st.OptionName, "{")
		g.Println("return func(cc *", st.Name, ")", st.OptionName, "{")
		g.Printf(`previous := cc.%[1]s
		cc.%[1]s = v
`, v.Name)
		g.Print("return ", v.GenFuncName(st), "(")
		if v.IsSlice() {
			g.Println("previous...)")
		} else {
			g.Println("previous)")
		}
		g.Println("}}")
		if v.IsSlice() && config.GenAppend {
			// func AppendTCPOption(v ...sandwich.Option) Option {
			// 	return func(cc *Options) Option {
			// 		previous := cc.TCPOption
			// 		n := make([]sandwich.Option, len(previous)+len(v))
			// 		copy(n, previous)
			// 		copy(n[len(previous):], v)
			// 		cc.TCPOption = n
			// 		return WithTCPOption(previous...)
			// 	}
			// }

			g.Print("func ", v.AppendFuncName(st), "(v ")
			g.Print("...", v.SliceType())
			g.Println(")", st.OptionName, "{")
			g.Println("return func(cc *", st.Name, ")", st.OptionName, "{")
			g.Printf(`previous := cc.%[1]s
  new := make([]%[2]s,0,len(v)+len(previous))
  new = append(new, previous...)
  new = append(new, v...)
  cc.%[1]s = new
`, v.Name, v.SliceType())
			g.Print("return ", v.GenFuncName(st), "(")
			g.Println("previous...)")
			g.Println("}}")
		}

	}

	g.Printf(`

// SetOption modify options
func (cc *%[1]s) SetOption(opt %[2]s) {
	_ = opt(cc)
}

// ApplyOption modify options
func (cc *%[1]s) ApplyOption(opts... %[2]s) {
	for _, opt := range opts  {
		_ = opt(cc)
	}
}

// GetSetOption modify and get last option
func (cc *%[1]s) GetSetOption(opt %[2]s) %[2]s {
	return opt(cc)
}

// %[2]s option define 
type %[2]s func(cc *%[1]s) %[2]s
`, st.Name, st.OptionName)

	g.Printf(`
// New%[1]s create options instance.
func New%[1]s(opts ... %[2]s) *%[1]s {
	cc := newDefault%[1]s()
	for _, opt := range opts  {
		_ = opt(cc)
	}
	if watchDog%[1]s != nil {
		watchDog%[1]s(cc)
	}
	return cc
}

// Install%[1]sWatchDog install watch dog
func Install%[1]sWatchDog(dog func(cc *%[1]s)) {
	watchDog%[1]s = dog
}

var watchDog%[1]s func(cc *%[1]s)

// newDefault%[1]s new option with default value
func newDefault%[1]s () *%[1]s {
	cc := &%[1]s{
`, st.Name, st.OptionName)
	// default options initialization
	for _, v := range st.Fields {
		if v.FieldType == FieldTypeFunc {
			g.Println(v.Name, ":", v.Type, v.Body, ",")
		} else {
			g.Println(v.Name, ":", v.Body, ",")
		}
	}
	g.Println(`
    }
    return cc
}
`)

	// fmt.Println(string(g.Buf.Bytes()))
	file := "gen_" + strings.ToLower(st.Name) + ".go"
	err := g.Write(file)
	util.FatalIfErr(err, "save output failed")
}

package imake

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"log"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strings"

	"github.com/aggronmagi/gogen/gen"
	"github.com/aggronmagi/gogen/goparse"
	"github.com/aggronmagi/gogen/internal/util"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var _ = util.Dump

// command config
var config = struct {
	TypeNames            []string // 指定生成的结构体名称
	StructMatch          string   // 使用正则匹配生成的结构体名称
	IgnoreUnexportStruct bool     // 忽略未导出结构体
	IgnoreUnexportMethod bool     // 忽略未导出的成员函数
	IgnoreEmptyStruct    bool     // 忽略没有函数的结构体
	ToPkg                string   // 生成的package名
	Output               string   // 生成的文件名
	IfaceSufix           string   // 生成接口名称的的后缀
	// Mock                 bool     // 为结构体生成mock
	BuildTags            []string
	match                *regexp.Regexp
}{
	ToPkg:                ".",
	IfaceSufix:           "IFace",
	IgnoreUnexportStruct: true,
	IgnoreUnexportMethod: true,
}

// Version generate tool version
var Version string = "0.0.1"

// Flags generate tool flags
func Flags(set *pflag.FlagSet) {
	set.StringSliceVarP(&config.TypeNames, "type", "t", config.TypeNames, "list of type names; current option is mutually exclusive with `match`")
	set.StringVarP(&config.StructMatch, "match", "m", "", "match struct name;current option is mutually exclusive with `type`")
	set.BoolVar(&config.IgnoreUnexportStruct, "ignore-unexport-struct", config.IgnoreUnexportStruct, "is ignore unexport struct")
	set.BoolVar(&config.IgnoreUnexportMethod, "ignore-unexport-method", config.IgnoreUnexportMethod, "is ignore unexport method")
	set.BoolVar(&config.IgnoreEmptyStruct, "ignore-empty-struct", config.IgnoreEmptyStruct, "ignore empty struct(not has funcions)")
	set.StringVarP(&config.Output, "output", "o", config.Output, "output file name; default stdout")
	set.StringVar(&config.ToPkg, "to", config.ToPkg, "generated package name")
	set.StringVarP(&config.IfaceSufix, "suffix", "s", config.IfaceSufix, "add interface name suffix")
	set.StringSliceVar(&config.BuildTags, "tags", config.BuildTags, "comma-separated list of build tags to apply")
	// set.BoolVar(&config.Mock, "mock", config.Mock, "generate struct mock functions")
}

// RunCommand run generate command
func RunCommand(cmd *cobra.Command, args []string) {
	////////////////////////////////////////////////////////////
	// parse args and options

	// We accept either one directory or a list of files. Which do we have?
	if len(args) == 0 {
		log.Println("not input files,package  or directory")
		cmd.Help()
		os.Exit(2)
	}
	if len(config.StructMatch) > 0 && len(config.TypeNames) > 0 {
		log.Println("Options match and type are mutually exclusive ")
	}
	if len(config.StructMatch) > 0 {
		config.match = regexp.MustCompile(config.StructMatch)
	}

	if config.ToPkg == "." {
		config.ToPkg = goparse.EnvGoPackage
	}

	// // check mockgen
	// if config.Mock {
	// 	exec.Command("command","-v", "mockgen").Run()
	// }

	// util.Dump(config)

	////////////////////////////////////////////////////////////////////////////////
	// parse packages..
	pkg, err := goparse.ParsePackage(args, config.BuildTags...)
	util.PanicIfErr(err, "parse input failed!")
	// is same package
	fromPkg := pkg.Package().Name
	// to fix not exec from go generate
	if config.ToPkg == "" {
		config.ToPkg = fromPkg
	}
	dstPkg := fromPkg
	if dstPkg == config.ToPkg {
		dstPkg = ""
	}
	// scan struct method
	data := ParsePackages(pkg, IsGenerateStruct, IsGenerateMethod, dstPkg)

	if len(data) < 1 {
		// no struct to genrate
		log.Println("not match any struct generate.")
		cmd.Help()
		os.Exit(2)
		return
	}

	// util.Dump(data)

	g := &gen.Generator{}
	// Print the header and package clause.
	g.Printf("// Code generated by \"gogen imake\"; DO NOT EDIT.\n")
	g.Printf("// Exec: \"gogen %s\"\n// Version: %s \n", strings.Join(os.Args[1:], " "), Version)
	g.Printf("\n")
	g.Printf("package %s", config.ToPkg)
	g.Printf("\n")
	if len(dstPkg) > 0 {
		g.Printf("import %s \"%s\"\n", fromPkg, pkg.Package().PkgPath)
	}

	keys := sortMapKey(data)

	for _, key := range keys {
		info := data[key]
		info.Methods = sortMethod(info.Methods)
		g.PrintDoc(info.Doc)
		g.Printf("type %s%s interface{\n", info.Typ, config.IfaceSufix)
		for _, v := range info.Composites {
			if !v.IsStruct {
				// interface composite
				g.Println(v.Typ)
				continue
			}
			g.Printf("%s%s\n", v.Typ, config.IfaceSufix)
		}
		// util.Dump(info.Composites)
		for _, method := range info.Methods {
			g.PrintDoc(method.Doc)
			g.Println(method)
		}
		g.Println("}")
		g.Println()
	}

	if len(config.Output) == 0 {
		out, err := gen.OptionGoimportsFormtat(g.Buf.Bytes())
		util.FatalIfErr(err, "generate code format")
		fmt.Println(string(out))
		return
	}
	err = g.Write(config.Output)
	util.FatalIfErr(err, "format and write result")

	// if !config.Mock {
	// 	return
	// }
	// out := bytes.NewBuffer(nil)
	// mockcmd := exec.Command("mockgen", "-version")
	// mockcmd.Stdout = out
	// err = mockcmd.Run()
	// util.FatalIfErr(err, "check mockgen version")
	// fmt.Println("mockgen version:", string(out.Bytes()))
	// mockcmd.Args = append([]string{"mockgen"})
	// mockcmd.Stdout = os.Stdout
	// mockcmd.Stderr = os.Stderr
}

func sortMapKey(in map[string]*StructInfo) (out []string) {
	for k, v := range in {
		if config.IgnoreEmptyStruct && len(v.Methods) == 0 {
			continue
		}
		out = append(out, k)
	}
	sort.Strings(out)
	return
}

func sortMethod(in []*StructMethod) []*StructMethod {
	sort.Slice(in, func(i, j int) bool {
		return in[i].Name < in[j].Name
	})
	return in
}

// IsGenerateStruct 是否生成结构体
func IsGenerateStruct(name string) bool {
	// 忽略未导出
	if config.IgnoreUnexportStruct &&
		!token.IsExported(name) {
		return false
	}
	// 优先使用指定具体生成的参数
	if len(config.TypeNames) > 0 {
		for _, v := range config.TypeNames {
			if v == name {
				return true
			}
		}
		return false
	}
	// 匹配
	if config.match != nil {
		return config.match.Match([]byte(name))
	}
	// 默认生成全部结构体
	return true
}

// IsGenerateMethod 是否生成结构体的方法
func IsGenerateMethod(name string) bool {
	// 忽略未导出
	if config.IgnoreUnexportMethod &&
		!token.IsExported(name) {
		return false
	}
	// 默认生成全部结构体
	return true
}

// GenerateStructInterface generate struct interface
func GenerateStructInterface(g *gen.Generator, decl *ast.GenDecl, typ *ast.TypeSpec, cm ast.CommentMap) {

}
